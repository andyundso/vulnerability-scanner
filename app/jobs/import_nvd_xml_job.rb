require 'net/http'
require Rails.root.join('lib', 'methods', 'import_methods')

class ImportNvdXmlJob < ApplicationJob
  queue_as :default

  def perform(xml_url='https://nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-Modified.xml.zip')
    # break execution if url does not have the extension ".xml.zip"
    exit unless xml_url.include? ".xml.zip"

    logger.info "#{Time.now}: Starting import of security vulnerabilities."

    # verify all directories are existing
    import_directory = ImportMethods.directory_to_save
    zip_filename = ImportMethods.file_name(xml_url, '.zip')
    FileUtils.mkdir_p(import_directory)

    # download file and copy to tmp
    ImportMethods.download_file(xml_url, "#{import_directory}/#{zip_filename}")

    # extract file (returns path to xml)
    xml_path = ImportMethods.extract_zip("#{import_directory}/#{zip_filename}", import_directory)

    # create a new ImportJob Object to reference all the vulnerabilities later
    import_job = Vul::ImportJob.create(file_path: xml_path)
    security_import = Nokogiri::XML(File.open(xml_path))

    security_import.xpath("//xmlns:nvd/xmlns:entry").each do |entry|
      # check if the issue was already imported once
      cve_id = entry.attribute("id").value
      vul = Vul::Vulnerability.find_by_cve_id(cve_id)

      if !vul.nil?
        # check if xml has a newer entry than database
        db_last_modified = DateTime.parse(vul.last_modified_datetime.to_s)
        xml_last_modified = DateTime.parse(entry.xpath('vuln:published-datetime').text)

        if db_last_modified <= xml_last_modified
          @update = true
          @import = false
        else
          @update = false
          @import = false
        end

      else
        # create new entry
        vul = Vul::Vulnerability.new
        @import = true
        @update =  false
      end

      if @import || @update
        # import / update all the information about the vulnerability
        vul.cve_id = cve_id
        vul.summary = entry.xpath('vuln:summary').text
        vul.published_datetime = DateTime.parse(entry.xpath('vuln:published-datetime').text)
        vul.last_modified_datetime = DateTime.parse(entry.xpath('vuln:published-datetime').text)

        # import all cvss parameters
        cvss_entries = entry.xpath('vuln:cvss').xpath('cvss:base_metrics')

        unless cvss_entries.empty?
          vul.cvss_score = cvss_entries.xpath('cvss:score').text
          vul.cvss_access_vector = cvss_entries.xpath('cvss:access-vector').text
          vul.cvss_access_complexity = cvss_entries.xpath('cvss:access-complexity').text
          vul.cvss_authentication = cvss_entries.xpath('cvss:authentication').text
          vul.cvss_confidentiality_impact = cvss_entries.xpath('cvss:confidentiality-impact').text
          vul.cvss_integrity_impact = cvss_entries.xpath('cvss:integrity-impact').text
          vul.cvss_availability_impact = cvss_entries.xpath('cvss:availability-impact').text
          vul.cvss_generated_on_datetime = DateTime.parse(cvss_entries.xpath('cvss:generated-on-datetime').text)
        end

        if vul.save
          logger.info "#{Time.now}: Imported Vulnerability: #{vul.inspect}."

          # creates a log entry about the issue
          import_log = Vul::ImportLog.new
          import_log.vulnerability_id = vul.id
          import_log.import_job_id = import_job.id
          import_log.action = @import ? 0 : 1

          if import_log.save
            logger.info "#{Time.now}: Made an import log entry: #{import_log.inspect}."

            # import of all the reference links for additional online documentation about the vulnerability
            if @update
              # if we're updating the existing entry, it should destroy all existing reference links
              # we could also make a separate "are all attributes the same"-tactic
              # tbh, deleting is a bit more simpler

              reference_links = Vul::Reference.where(:vulnerability_id => vul.id)
              unless reference_links.nil?
                reference_links.each do |link|
                  link.destroy
                end
              end
            end

            entry.xpath('vuln:references').each do |reference|
              ref = Vul::Reference.new

              ref.vulnerability_id = vul.id
              ref.reference_type = reference.attribute('reference_type').value
              ref.source = reference.xpath('vuln:source').text
              ref.reference_url = reference.xpath('vuln:reference').attribute('href').value

              if ref.save
                logger.info "#{Time.now}: Imported Vulnerability link: #{ref.inspect}"
              else
                logger.info "Could not save reference link entry: #{ref.errors.full_messages}"
                exit
              end
            end

            # import affected software based on delivered CPE records
            entry.xpath('vuln:vulnerable-software-list').xpath('vuln:product').each do |software|
              properties = software.text.split(':')

              # calling first or create because it's very likely that already a record for this software is existing
              vendor = Sft::Vendor.where(:name => properties[2].titleize).first_or_create
              software = Sft::Software.where(:vendor_id => vendor.id, :name => properties[3].titleize).first_or_create
              software_version = Sft::Version.where(:software_id => software.id,
                                                               :version => properties[4]).first_or_create

              if vendor.save || software.save || software_version.save
                # make a relation between software version and vulnerability
                software_version.vulnerabilities << vul

                unless software_version.save
                  logger.info "Could not save software: #{software_version.errors.full_messages}"
                end

              else
                logger.info "Could not save software: #{vendor.errors.full_messages}, #{software.errors.full_messages}, #{software_version.errors.full_messages}"
                exit
              end
            end
          else
            logger.info "Could not save Import Log entry: #{import_log.errors.full_messages}"
            exit
          end
        else
          # exit code if vulnerability could not been saved
          logger.info "Could not save vulnerability: #{vul.errors.full_messages}."
          exit
        end

      end
    end
  end
end
